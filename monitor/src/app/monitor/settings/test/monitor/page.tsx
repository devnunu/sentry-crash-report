'use client'

import React, { useState, useEffect, useMemo } from 'react'
import {
  ActionIcon,
  Badge,
  Button,
  Card,
  Divider,
  Group,
  Modal,
  NumberInput,
  Progress,
  Radio,
  ScrollArea,
  Select,
  Stack,
  Text,
  TextInput,
  Timeline,
  Title
} from '@mantine/core'
import { notifications } from '@mantine/notifications'
import { IconClock, IconFilter, IconPlayerPause, IconPlayerPlay, IconRefresh, IconSearch, IconSquare } from '@tabler/icons-react'
import type { Platform } from '@/lib/types'

// ===== Data Structures =====
interface TestMonitor {
  id: string
  platform: Platform
  version: string
  intervalMinutes: number
  durationDays: number
  startedAt: string
  nextRunAt: string
  runCount: number
  expectedRuns: number
  notificationsSent: number
  notificationsFailed: number
  lastNotificationAt: string | null
  isPaused: boolean
}

interface TestLog {
  id: string
  testId: string
  type: 'run' | 'notification' | 'error' | 'success'
  timestamp: string
  title: string
  message: string
  data?: any
  error?: string
}

interface Release {
  version: string
  dateReleased?: string
  dateCreated?: string
  environments?: string[]
  projectMatched?: boolean
  environmentMatched?: boolean
}

interface ApiResponse<T> {
  success: boolean
  data?: T
  error?: string
}

// ===== Helper Functions =====
function getNextRunTime(nextRunAt: string): string {
  const next = new Date(nextRunAt)
  const now = new Date()
  const diff = next.getTime() - now.getTime()

  if (diff < 0) return 'Í≥ß Ïã§Ìñâ'

  const minutes = Math.floor(diff / 60000)
  const seconds = Math.floor((diff % 60000) / 1000)

  if (minutes > 0) return `${minutes}Î∂Ñ ${seconds}Ï¥à ÌõÑ`
  return `${seconds}Ï¥à ÌõÑ`
}

function getProgress(runCount: number, expectedRuns: number): number {
  if (expectedRuns === 0) return 0
  return Math.min(100, Math.round((runCount / expectedRuns) * 100))
}

function getNextCheckpoints(runCount: number, expectedRuns: number): string[] {
  const checkpoints: string[] = []
  const progress = (runCount / expectedRuns) * 100

  if (progress < 25) checkpoints.push('25% ÏôÑÎ£å')
  if (progress < 50) checkpoints.push('50% ÏôÑÎ£å')
  if (progress < 75) checkpoints.push('75% ÏôÑÎ£å')
  if (progress < 100) checkpoints.push('100% ÏôÑÎ£å')

  return checkpoints.slice(0, 2)
}

function getLogIcon(type: TestLog['type']): React.ReactNode {
  switch (type) {
    case 'run':
      return <IconPlayerPlay size={16} />
    case 'notification':
      return <IconClock size={16} />
    case 'error':
      return '‚ùå'
    case 'success':
      return '‚úÖ'
    default:
      return 'üìù'
  }
}

function formatDateTime(dateStr: string): string {
  const date = new Date(dateStr)
  return new Intl.DateTimeFormat('ko-KR', {
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  }).format(date)
}

function getRelativeTime(dateStr: string): string {
  const date = new Date(dateStr)
  const now = new Date()
  const diff = now.getTime() - date.getTime()

  const minutes = Math.floor(diff / 60000)
  const hours = Math.floor(minutes / 60)
  const days = Math.floor(hours / 24)

  if (days > 0) return `${days}Ïùº Ï†Ñ`
  if (hours > 0) return `${hours}ÏãúÍ∞Ñ Ï†Ñ`
  if (minutes > 0) return `${minutes}Î∂Ñ Ï†Ñ`
  return 'Î∞©Í∏à Ï†Ñ'
}

// Î≤†Ïù¥Ïä§ Î≤ÑÏ†Ñ Ï∂îÏ∂ú - API Ï†ÑÏÜ°Ïö© (4.72.0.0+546 ‚Üí 4.72.0)
function getBaseVersionForAPI(version: string): string {
  const withoutBuildNumber = version.split('+')[0].split('-')[0]
  const parts = withoutBuildNumber.split('.')
  // Ï≤òÏùå 3Í∞ú Î∂ÄÎ∂ÑÎßå Ï∂îÏ∂ú (x.y.z ÌòïÏãù)
  return parts.slice(0, 3).join('.')
}

// Ï†ÑÏ≤¥ Î≤ÑÏ†Ñ (ÎπåÎìú Î≤àÌò∏ Ï†úÏô∏) - Ï§ëÎ≥µ Ï†úÍ±∞Ïö© (4.72.0.0+546 ‚Üí 4.72.0.0)
function getVersionWithoutBuild(version: string): string {
  return version.split('+')[0].split('-')[0]
}

// Î≤ÑÏ†Ñ ÏΩîÎìú Ï∂îÏ∂ú (4.72.0+920 ‚Üí 920)
function getVersionCode(version: string): number {
  const parts = version.split('+')
  if (parts.length > 1) {
    const code = parseInt(parts[1])
    return isNaN(code) ? 0 : code
  }
  return 0
}

// Ï§ëÎ≥µ Ï†úÍ±∞ (Í∞ôÏùÄ Î≤ÑÏ†Ñ + ÎπåÎìú Î≤àÌò∏ Îã§Î•∏ Í≤ÉÎßå Ï§ëÎ≥µ Ï≤òÎ¶¨)
// Ïòà: 4.72.0+912ÏôÄ 4.72.0+920 ‚Üí 920Îßå ÎÇ®Ïùå
// Ïòà: 4.72.0+912ÏôÄ 4.72.0.0+546 ‚Üí Îëò Îã§ Ïú†ÏßÄ (Îã§Î•∏ Î≤ÑÏ†Ñ)
function deduplicateReleases(releases: Release[]): Release[] {
  const versionMap = new Map<string, Release>()

  releases.forEach(release => {
    // ÎπåÎìú Î≤àÌò∏Î•º Ï†úÏô∏Ìïú Ï†ÑÏ≤¥ Î≤ÑÏ†ÑÏùÑ ÌÇ§Î°ú ÏÇ¨Ïö© (4.72.0.0+546 ‚Üí 4.72.0.0)
    const versionKey = getVersionWithoutBuild(release.version)
    const existing = versionMap.get(versionKey)

    if (!existing) {
      versionMap.set(versionKey, release)
      return
    }

    // Î≤ÑÏ†Ñ ÏΩîÎìú ÎπÑÍµê
    const releaseCode = getVersionCode(release.version)
    const existingCode = getVersionCode(existing.version)

    if (releaseCode !== existingCode) {
      if (releaseCode > existingCode) {
        versionMap.set(versionKey, release)
      }
      return
    }

    // Î≤ÑÏ†Ñ ÏΩîÎìúÍ∞Ä Í∞ôÏúºÎ©¥ ÎÇ†ÏßúÎ°ú ÎπÑÍµê
    const releaseDate = new Date(release.dateReleased || release.dateCreated || 0)
    const existingDate = new Date(existing.dateReleased || existing.dateCreated || 0)

    if (releaseDate > existingDate) {
      versionMap.set(versionKey, release)
    }
  })

  return Array.from(versionMap.values())
}

export default function MonitorTestPage() {
  // Form state for new tests
  const [platform, setPlatform] = useState<Platform>('android')
  const [searchQuery, setSearchQuery] = useState('')
  const [selectedRelease, setSelectedRelease] = useState('')
  const [duration, setDuration] = useState('1')
  const [intervalMinutes, setIntervalMinutes] = useState(5)
  const [isStarting, setIsStarting] = useState(false)

  // Release search state
  const [allReleases, setAllReleases] = useState<Release[]>([])
  const [isSearching, setIsSearching] = useState(false)

  // Active tests state
  const [activeTests, setActiveTests] = useState<TestMonitor[]>([])
  const [isLoadingActive, setIsLoadingActive] = useState(true)

  // Logs modal state
  const [logsModalOpened, setLogsModalOpened] = useState(false)
  const [selectedTestId, setSelectedTestId] = useState<string | null>(null)
  const [logs, setLogs] = useState<TestLog[]>([])
  const [logFilter, setLogFilter] = useState<'all' | 'run' | 'notification' | 'error'>('all')
  const [isLoadingLogs, setIsLoadingLogs] = useState(false)

  // History state
  const [history, setHistory] = useState<TestMonitor[]>([])
  const [isLoadingHistory, setIsLoadingHistory] = useState(true)

  // Platform Î≥ÄÍ≤Ω Ïãú Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    setSearchQuery('')
    setSelectedRelease('')
    setAllReleases([])
  }, [platform])

  // Load active tests on mount
  useEffect(() => {
    loadActiveTests()
    loadHistory()

    // Refresh every 30 seconds
    const interval = setInterval(() => {
      loadActiveTests()
    }, 30000)

    return () => clearInterval(interval)
  }, [])

  // ÌïÑÌÑ∞ÎßÅÎêú Î¶¥Î¶¨Ï¶à (Ï§ëÎ≥µ Ï†úÍ±∞, Ï†ïÎ†¨)
  const filteredReleases = useMemo(() => {
    let releases = [...allReleases]

    // Í≤ÄÏÉâÏñ¥ ÌïÑÌÑ∞ÎßÅ
    if (searchQuery) {
      const query = searchQuery.toLowerCase()
      releases = releases.filter(r =>
        r.version.toLowerCase().includes(query)
      )
    }

    // Ï§ëÎ≥µ Ï†úÍ±∞
    releases = deduplicateReleases(releases)

    // ÏµúÏã†Ïàú Ï†ïÎ†¨ (ÎÇ†Ïßú Ïö∞ÏÑ†, Î≤ÑÏ†Ñ ÏΩîÎìúÎäî Î∂ÄÏ∞®Ï†Å)
    releases.sort((a, b) => {
      // Î®ºÏ†Ä ÎÇ†ÏßúÎ°ú ÎπÑÍµê
      const dateA = new Date(a.dateReleased || a.dateCreated || 0)
      const dateB = new Date(b.dateReleased || b.dateCreated || 0)

      if (dateA.getTime() !== dateB.getTime()) {
        return dateB.getTime() - dateA.getTime()
      }

      // ÎÇ†ÏßúÍ∞Ä Í∞ôÏúºÎ©¥ Î≤ÑÏ†Ñ ÏΩîÎìúÎ°ú ÎπÑÍµê
      const codeA = getVersionCode(a.version)
      const codeB = getVersionCode(b.version)
      return codeB - codeA
    })

    return releases.slice(0, 10)
  }, [allReleases, searchQuery])

  const searchReleases = async () => {
    if (!searchQuery.trim()) {
      notifications.show({ color: 'orange', message: 'Í≤ÄÏÉâÏñ¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî' })
      return
    }

    setIsSearching(true)

    try {
      const params = new URLSearchParams({
        platform,
        baseRelease: searchQuery.trim()
      })

      const response = await fetch(`/api/monitor/releases?${params.toString()}`)
      const result = await response.json()

      if (!response.ok || !result.success) {
        throw new Error(result.error || 'Î¶¥Î¶¨Ï¶à Í≤ÄÏÉâÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§')
      }

      const releases = result.data?.releases || []
      setAllReleases(releases)

      if (releases.length === 0) {
        notifications.show({ color: 'orange', message: 'Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§' })
      }
    } catch (err) {
      const m = err instanceof Error ? err.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§'
      notifications.show({ color: 'red', message: `Î¶¥Î¶¨Ï¶à Í≤ÄÏÉâ Ïã§Ìå®: ${m}` })
    } finally {
      setIsSearching(false)
    }
  }

  const loadActiveTests = async () => {
    try {
      const response = await fetch('/api/test-monitors/active')
      const result: ApiResponse<TestMonitor[]> = await response.json()

      if (result.success && result.data) {
        setActiveTests(result.data)
      }
    } catch (error) {
      console.error('Failed to load active tests:', error)
    } finally {
      setIsLoadingActive(false)
    }
  }

  const loadHistory = async () => {
    try {
      const response = await fetch('/api/test-monitors/history?limit=5')
      const result: ApiResponse<TestMonitor[]> = await response.json()

      if (result.success && result.data) {
        setHistory(result.data)
      }
    } catch (error) {
      console.error('Failed to load history:', error)
    } finally {
      setIsLoadingHistory(false)
    }
  }

  const loadLogs = async (testId: string) => {
    setIsLoadingLogs(true)
    try {
      const response = await fetch(`/api/test-monitors/${testId}/logs?type=${logFilter}`)
      const result: ApiResponse<TestLog[]> = await response.json()

      if (result.success && result.data) {
        setLogs(result.data)
      }
    } catch (error) {
      console.error('Failed to load logs:', error)
      notifications.show({ color: 'red', message: 'Î°úÍ∑∏Î•º Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.' })
    } finally {
      setIsLoadingLogs(false)
    }
  }

  const handleStartTest = async (event: React.FormEvent) => {
    event.preventDefault()

    if (!selectedRelease) {
      notifications.show({ color: 'red', message: 'Î≤†Ïù¥Ïä§ Î¶¥Î¶¨Ï¶àÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.' })
      return
    }

    setIsStarting(true)

    try {
      // Ï†ÑÏ≤¥ Î≤ÑÏ†ÑÏóêÏÑú Î≤†Ïù¥Ïä§ Î≤ÑÏ†ÑÎßå Ï∂îÏ∂ú (4.72.0.0+546 ‚Üí 4.72.0)
      const baseReleaseOnly = getBaseVersionForAPI(selectedRelease)

      const response = await fetch('/api/monitor/start-test', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          platform,
          baseRelease: baseReleaseOnly,
          matchedRelease: selectedRelease, // ÏÑ†ÌÉùÌïú Ï†ÑÏ≤¥ Î≤ÑÏ†ÑÏùÑ Ï†ÑÏÜ°
          days: parseInt(duration),
          isTestMode: true,
          customInterval: intervalMinutes
        })
      })

      const result: ApiResponse<any> = await response.json()

      if (!response.ok || !result.success) {
        throw new Error(result.error || 'ÌÖåÏä§Ìä∏ ÏãúÏûëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
      }

      notifications.show({ color: 'green', message: 'ÌÖåÏä§Ìä∏ Î™®ÎãàÌÑ∞ÎßÅÏù¥ ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.' })
      setSelectedRelease('')
      setSearchQuery('')
      setAllReleases([])
      await loadActiveTests()
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      notifications.show({ color: 'red', message })
    } finally {
      setIsStarting(false)
    }
  }

  const handlePauseTest = async (testId: string) => {
    try {
      const response = await fetch(`/api/test-monitors/${testId}/pause`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' }
      })

      const result: ApiResponse<any> = await response.json()

      if (!response.ok || !result.success) {
        throw new Error(result.error || 'ÏùºÏãúÏ†ïÏßÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
      }

      notifications.show({ color: 'orange', message: 'ÌÖåÏä§Ìä∏Í∞Ä ÏùºÏãúÏ†ïÏßÄÎêòÏóàÏäµÎãàÎã§.' })
      await loadActiveTests()
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      notifications.show({ color: 'red', message })
    }
  }

  const handleStopTest = async (testId: string) => {
    try {
      const response = await fetch(`/api/test-monitors/${testId}`, {
        method: 'DELETE'
      })

      const result: ApiResponse<any> = await response.json()

      if (!response.ok || !result.success) {
        throw new Error(result.error || 'Ï§ëÏßÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
      }

      notifications.show({ color: 'red', message: 'ÌÖåÏä§Ìä∏Í∞Ä Ï§ëÏßÄÎêòÏóàÏäµÎãàÎã§.' })
      await loadActiveTests()
      await loadHistory()
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
      notifications.show({ color: 'red', message })
    }
  }

  const openLogsModal = (testId: string) => {
    setSelectedTestId(testId)
    setLogsModalOpened(true)
    loadLogs(testId)
  }

  useEffect(() => {
    if (selectedTestId && logsModalOpened) {
      loadLogs(selectedTestId)
    }
  }, [logFilter])

  const filteredLogs = logs.filter(log => {
    if (logFilter === 'all') return true
    return log.type === logFilter
  })

  return (
    <div className="container">
      <Group justify="space-between" align="flex-start" mb="xl">
        <div>
          <Title order={2}>üì° Î™®ÎãàÌÑ∞ÎßÅ ÌÖåÏä§Ìä∏ ÎåÄÏãúÎ≥¥Îìú</Title>
          <Text c="dimmed" size="sm">Ïã§ÏãúÍ∞Ñ ÏßÑÌñâ ÏÉÅÌô©Í≥º Í≤ÄÏ¶ù Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî</Text>
        </div>
        <Button
          leftSection={<IconRefresh size={16} />}
          variant="light"
          onClick={() => {
            loadActiveTests()
            loadHistory()
          }}
        >
          ÏÉàÎ°úÍ≥†Ïπ®
        </Button>
      </Group>

      {/* Section 1: Active Tests */}
      <Card withBorder radius="md" p="xl" mb="xl" style={{ background: 'linear-gradient(135deg, rgba(34, 197, 94, 0.05) 0%, rgba(16, 185, 129, 0.05) 100%)', borderColor: 'rgba(34, 197, 94, 0.2)' }}>
        <Stack gap="md">
          <Group justify="space-between">
            <div>
              <Text size="lg" fw={600}>ÏßÑÌñâ Ï§ëÏù∏ ÌÖåÏä§Ìä∏</Text>
              <Text size="xs" c="dimmed">ÌôúÏÑ± Î™®ÎãàÌÑ∞ÎßÅ ÌÖåÏä§Ìä∏Ïùò ÏßÑÌñâ ÏÉÅÌô©</Text>
            </div>
            {activeTests.length > 0 && (
              <Badge color="green" variant="light" size="lg">{activeTests.length}Í∞ú Ïã§Ìñâ Ï§ë</Badge>
            )}
          </Group>

          {isLoadingActive ? (
            <Text c="dimmed" ta="center" py="xl">Î°úÎî© Ï§ë...</Text>
          ) : activeTests.length === 0 ? (
            <Card withBorder p="xl" style={{ backgroundColor: 'rgba(148, 163, 184, 0.05)' }}>
              <Stack align="center" gap="xs">
                <Text c="dimmed" size="sm">ÏßÑÌñâ Ï§ëÏù∏ ÌÖåÏä§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§</Text>
                <Text c="dimmed" size="xs">ÏïÑÎûò ÌèºÏóêÏÑú ÏÉà ÌÖåÏä§Ìä∏Î•º ÏãúÏûëÌïòÏÑ∏Ïöî</Text>
              </Stack>
            </Card>
          ) : (
            <Stack gap="md">
              {activeTests.map(test => {
                const progress = getProgress(test.runCount, test.expectedRuns)
                const checkpoints = getNextCheckpoints(test.runCount, test.expectedRuns)
                const notificationSuccess = test.notificationsSent - test.notificationsFailed

                return (
                  <Card key={test.id} padding="lg" withBorder style={test.isPaused ? { backgroundColor: 'rgba(234, 179, 8, 0.05)' } : undefined}>
                    <Stack gap="md">
                      {/* Ìó§Îçî */}
                      <Group justify="space-between">
                        <Group gap="xs">
                          <Text size="lg" fw={600}>
                            {test.platform === 'android' ? 'ü§ñ' : 'üçé'} {test.platform.toUpperCase()} {test.version}
                          </Text>
                          <Badge color="violet" variant="light" size="sm">
                            ÌÖåÏä§Ìä∏ Î™®Îìú
                          </Badge>
                          {test.isPaused && <Badge color="yellow">ÏùºÏãúÏ†ïÏßÄ</Badge>}
                        </Group>
                        <Group gap="xs">
                          <ActionIcon
                            variant="light"
                            color={test.isPaused ? 'green' : 'yellow'}
                            onClick={() => handlePauseTest(test.id)}
                          >
                            {test.isPaused ? <IconPlayerPlay size={16} /> : <IconPlayerPause size={16} />}
                          </ActionIcon>
                          <ActionIcon
                            variant="light"
                            color="red"
                            onClick={() => handleStopTest(test.id)}
                          >
                            <IconSquare size={16} />
                          </ActionIcon>
                        </Group>
                      </Group>

                      {/* ÏßÑÌñâ ÏÉÅÌô© */}
                      <div>
                        <Text size="sm" fw={600} mb={4}>üóìÔ∏è ÏßÑÌñâ ÏÉÅÌô©</Text>
                        <Stack gap="xs">
                          <Text size="sm" c="dimmed">
                            ‚Ä¢ ÏãúÏûë: {formatDateTime(test.startedAt)}
                          </Text>
                          <Text size="sm" c="dimmed">
                            ‚Ä¢ Ïã§Ìñâ Í∞ÑÍ≤©: {test.intervalMinutes}Î∂ÑÎßàÎã§
                          </Text>
                          <Text size="sm" c="dimmed">
                            ‚Ä¢ Îã§Ïùå Ïã§Ìñâ: {test.isPaused ? 'ÏùºÏãúÏ†ïÏßÄÎê®' : getNextRunTime(test.nextRunAt)}
                          </Text>
                          <Group gap="xs">
                            <Text size="sm" c="dimmed">‚Ä¢ ÏßÑÌñâÎ•†:</Text>
                            <Progress
                              value={progress}
                              style={{ flex: 1 }}
                              color={progress > 80 ? 'orange' : 'blue'}
                            />
                            <Text size="sm" fw={500}>
                              {progress}%
                            </Text>
                          </Group>
                          <Text size="sm" c="dimmed">
                            ‚Ä¢ Ïã§Ìñâ ÌöüÏàò: {test.runCount} / {test.expectedRuns}Ìöå
                          </Text>
                        </Stack>
                      </div>

                      {/* ÏïåÎ¶º ÏÉÅÌÉú */}
                      <div>
                        <Text size="sm" fw={600} mb={4}>üìä ÏïåÎ¶º ÏÉÅÌÉú</Text>
                        <Stack gap="xs">
                          <Text size="sm">
                            ‚Ä¢ Î∞úÏÜ° ÏÑ±Í≥µ: {notificationSuccess}Í±¥
                          </Text>
                          <Text size="sm">
                            ‚Ä¢ Î∞úÏÜ° Ïã§Ìå®: {test.notificationsFailed}Í±¥
                          </Text>
                          {test.lastNotificationAt && (
                            <Text size="sm" c="dimmed">
                              ‚Ä¢ ÎßàÏßÄÎßâ Î∞úÏÜ°: {formatDateTime(test.lastNotificationAt)}
                            </Text>
                          )}
                        </Stack>
                      </div>

                      {checkpoints.length > 0 && (
                        <div>
                          <Text size="sm" fw={600} mb={4}>üéØ Îã§Ïùå Ï≤¥ÌÅ¨Ìè¨Ïù∏Ìä∏</Text>
                          <Group gap="xs">
                            {checkpoints.map((checkpoint, idx) => (
                              <Badge key={idx} variant="light" color="violet">
                                {checkpoint}
                              </Badge>
                            ))}
                          </Group>
                        </div>
                      )}

                      {/* Ïï°ÏÖò Î≤ÑÌäº */}
                      <Group gap="xs">
                        <Button
                          size="sm"
                          variant="light"
                          leftSection={<IconClock size={16} />}
                          onClick={() => openLogsModal(test.id)}
                        >
                          Ïã§ÏãúÍ∞Ñ Î°úÍ∑∏
                        </Button>
                      </Group>
                    </Stack>
                  </Card>
                )
              })}
            </Stack>
          )}
        </Stack>
      </Card>

      {/* New Test Form */}
      <Card withBorder radius="md" p="xl" mb="xl" style={{ background: 'linear-gradient(135deg, rgba(168, 85, 247, 0.05) 0%, rgba(147, 51, 234, 0.05) 100%)', borderColor: 'rgba(168, 85, 247, 0.2)' }}>
        <form onSubmit={handleStartTest}>
          <Stack gap="md">
            <Text size="lg" fw={600}>ÏÉà ÌÖåÏä§Ìä∏ ÏãúÏûë</Text>

            {/* ÌîåÎû´Ìèº ÏÑ†ÌÉù */}
            <Select
              label="ÌîåÎû´Ìèº"
              data={[
                { value: 'android', label: 'Android' },
                { value: 'ios', label: 'iOS' }
              ]}
              value={platform}
              onChange={val => setPlatform((val as Platform) ?? 'android')}
              allowDeselect={false}
              required
            />

            <Divider />

            {/* Î≤†Ïù¥Ïä§ Î¶¥Î¶¨Ï¶à ÏÑ†ÌÉù */}
            <div>
              <Text size="sm" fw={500} mb={4}>Î≤†Ïù¥Ïä§ Î¶¥Î¶¨Ï¶à</Text>
              <Text size="xs" c="dimmed" mb="md">
                Î™®Îì† Î¶¥Î¶¨Ï¶à ÌëúÏãú (Í∞ôÏùÄ Î≤ÑÏ†ÑÏùÄ Î≤ÑÏ†Ñ ÏΩîÎìúÍ∞Ä ÎÜíÏùÄ Í≤ÉÎßå ÌëúÏãú)
              </Text>

              {/* Í≤ÄÏÉâÏ∞Ω */}
              <Group mb="md">
                <TextInput
                  placeholder="Î≤ÑÏ†Ñ Í≤ÄÏÉâ... (Ïòà: 4.72.0)"
                  leftSection={<IconSearch size={16} />}
                  value={searchQuery}
                  onChange={e => setSearchQuery(e.target.value)}
                  onKeyDown={e => {
                    if (e.key === 'Enter') {
                      e.preventDefault()
                      searchReleases()
                    }
                  }}
                  style={{ flex: 1 }}
                />
                <ActionIcon
                  variant="light"
                  onClick={searchReleases}
                  loading={isSearching}
                  size="lg"
                >
                  <IconSearch size={16} />
                </ActionIcon>
              </Group>

              {/* Î¶¥Î¶¨Ï¶à Î™©Î°ù */}
              <ScrollArea h={300} type="auto">
                <Stack gap="xs">
                  <Text size="xs" fw={600} c="dimmed" mb={4}>
                    üì¶ ÏµúÍ∑º Î¶¥Î¶¨Ï¶à
                  </Text>

                  {allReleases.length === 0 ? (
                    <Text size="sm" c="dimmed" ta="center" py="xl">
                      Í≤ÄÏÉâ Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò<br />
                      Î≤ÑÏ†ÑÏùÑ ÏûÖÎ†• ÌõÑ EnterÎ•º ÎàåÎü¨ Í≤ÄÏÉâÌïòÏÑ∏Ïöî
                    </Text>
                  ) : filteredReleases.length === 0 ? (
                    <Text size="sm" c="dimmed" ta="center" py="xl">
                      Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§
                    </Text>
                  ) : (
                    <Radio.Group
                      value={selectedRelease}
                      onChange={setSelectedRelease}
                    >
                      <Stack gap="xs">
                        {filteredReleases.map((release, idx) => {
                          const deployDate = release.dateReleased || release.dateCreated
                          const versionCode = getVersionCode(release.version)
                          return (
                            <Card
                              key={release.version}
                              padding="sm"
                              withBorder
                              style={{
                                cursor: 'pointer',
                                borderColor: selectedRelease === release.version
                                  ? 'var(--mantine-color-blue-6)'
                                  : undefined
                              }}
                              onClick={() => setSelectedRelease(release.version)}
                            >
                              <Group wrap="nowrap">
                                <Radio value={release.version} />
                                <div style={{ flex: 1 }}>
                                  <Group gap="xs">
                                    <Text size="sm" fw={500}>
                                      {release.version}
                                    </Text>
                                    {idx === 0 && (
                                      <Badge size="xs" color="cyan">ÏµúÏã†</Badge>
                                    )}
                                    {versionCode > 0 && (
                                      <Badge size="xs" color="gray" variant="light">
                                        +{versionCode}
                                      </Badge>
                                    )}
                                    {release.environmentMatched && (
                                      <Badge size="xs" color="green">‚òÖ ÌôòÍ≤Ω ÏùºÏπò</Badge>
                                    )}
                                  </Group>
                                  <Text size="xs" c="dimmed">
                                    {formatDateTime(deployDate)} Î∞∞Ìè¨
                                  </Text>
                                  <Text size="xs" c="dimmed">
                                    {release.environments?.join(', ') || 'env Ï†ïÎ≥¥ ÏóÜÏùå'} ¬∑ {getRelativeTime(deployDate || '')}
                                  </Text>
                                </div>
                              </Group>
                            </Card>
                          )
                        })}
                      </Stack>
                    </Radio.Group>
                  )}
                </Stack>
              </ScrollArea>
            </div>

            <Divider />

            {/* Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï */}
            <Select
              label="Î™®ÎãàÌÑ∞ÎßÅ Í∏∞Í∞Ñ"
              data={[
                { value: '1', label: '1Ïùº' },
                { value: '2', label: '2Ïùº' },
                { value: '3', label: '3Ïùº' }
              ]}
              value={duration}
              onChange={val => setDuration(val ?? '1')}
              allowDeselect={false}
            />

            <NumberInput
              label="ÌÖåÏä§Ìä∏ Ïã§Ìñâ Í∞ÑÍ≤© (Î∂Ñ)"
              description="ÌÖåÏä§Ìä∏ Î™®Îìú Ï†ÑÏö© ÏÑ§Ï†ï"
              value={intervalMinutes}
              onChange={value => setIntervalMinutes(Number(value) || 5)}
              min={1}
              max={60}
            />

            <Button
              type="submit"
              color="violet"
              leftSection="üöÄ"
              loading={isStarting}
              disabled={!selectedRelease}
            >
              {isStarting ? 'ÏãúÏûë Ï§ë...' : 'ÌÖåÏä§Ìä∏ ÏãúÏûë'}
            </Button>
          </Stack>
        </form>
      </Card>

      {/* Section 2: History */}
      <Card withBorder radius="md" p="xl" style={{ background: 'linear-gradient(135deg, rgba(148, 163, 184, 0.05) 0%, rgba(100, 116, 139, 0.05) 100%)', borderColor: 'rgba(148, 163, 184, 0.2)' }}>
        <Stack gap="md">
          <Text size="lg" fw={600}>ÏµúÍ∑º ÌÖåÏä§Ìä∏ ÌûàÏä§ÌÜ†Î¶¨</Text>

          {isLoadingHistory ? (
            <Text c="dimmed" ta="center" py="xl">Î°úÎî© Ï§ë...</Text>
          ) : history.length === 0 ? (
            <Card withBorder p="xl" style={{ backgroundColor: 'rgba(148, 163, 184, 0.05)' }}>
              <Text c="dimmed" size="sm" ta="center">ÌûàÏä§ÌÜ†Î¶¨Í∞Ä ÏóÜÏäµÎãàÎã§</Text>
            </Card>
          ) : (
            <Stack gap="xs">
              {history.map(test => {
                const progress = getProgress(test.runCount, test.expectedRuns)
                const isSuccess = progress === 100 && test.notificationsFailed === 0

                return (
                  <Card key={test.id} withBorder p="md" style={{ backgroundColor: isSuccess ? 'rgba(34, 197, 94, 0.05)' : 'rgba(239, 68, 68, 0.05)' }}>
                    <Group justify="space-between">
                      <div>
                        <Group gap="xs">
                          <Badge color={test.platform === 'android' ? 'blue' : 'gray'} size="sm">
                            {test.platform === 'android' ? 'Android' : 'iOS'}
                          </Badge>
                          <Text size="sm" fw={500}>{test.version}</Text>
                          <Badge color={isSuccess ? 'green' : 'red'} size="sm">
                            {isSuccess ? 'ÏÑ±Í≥µ' : 'Ïã§Ìå®'}
                          </Badge>
                        </Group>
                        <Text size="xs" c="dimmed" mt={4}>
                          {getRelativeTime(test.startedAt)} ¬∑ {test.runCount}/{test.expectedRuns} Ïã§Ìñâ ¬∑ ÏïåÎ¶º {test.notificationsSent - test.notificationsFailed}/{test.notificationsSent}
                        </Text>
                      </div>
                      <Button
                        variant="subtle"
                        size="xs"
                        onClick={() => openLogsModal(test.id)}
                      >
                        Î°úÍ∑∏ Î≥¥Í∏∞
                      </Button>
                    </Group>
                  </Card>
                )
              })}
            </Stack>
          )}
        </Stack>
      </Card>

      {/* Section 3: Real-time Logs Modal */}
      <Modal
        opened={logsModalOpened}
        onClose={() => setLogsModalOpened(false)}
        title="Ïã§ÏãúÍ∞Ñ Î°úÍ∑∏"
        size="xl"
      >
        <Stack gap="md">
          <Group justify="space-between">
            <Group gap="xs">
              <ActionIcon
                variant={logFilter === 'all' ? 'filled' : 'light'}
                onClick={() => setLogFilter('all')}
              >
                <IconFilter size={16} />
              </ActionIcon>
              <Badge
                variant={logFilter === 'run' ? 'filled' : 'light'}
                style={{ cursor: 'pointer' }}
                onClick={() => setLogFilter('run')}
              >
                Ïã§Ìñâ
              </Badge>
              <Badge
                variant={logFilter === 'notification' ? 'filled' : 'light'}
                color="blue"
                style={{ cursor: 'pointer' }}
                onClick={() => setLogFilter('notification')}
              >
                ÏïåÎ¶º
              </Badge>
              <Badge
                variant={logFilter === 'error' ? 'filled' : 'light'}
                color="red"
                style={{ cursor: 'pointer' }}
                onClick={() => setLogFilter('error')}
              >
                ÏóêÎü¨
              </Badge>
            </Group>
            <Button
              size="xs"
              variant="light"
              leftSection={<IconRefresh size={14} />}
              onClick={() => selectedTestId && loadLogs(selectedTestId)}
              loading={isLoadingLogs}
            >
              ÏÉàÎ°úÍ≥†Ïπ®
            </Button>
          </Group>

          <Group grow>
            <Card withBorder p="sm" style={{ backgroundColor: 'rgba(59, 130, 246, 0.05)' }}>
              <Text size="xs" c="dimmed">Ï¥ù Ïã§Ìñâ</Text>
              <Text size="lg" fw={600} c="blue">{logs.filter(l => l.type === 'run').length}</Text>
            </Card>
            <Card withBorder p="sm" style={{ backgroundColor: 'rgba(34, 197, 94, 0.05)' }}>
              <Text size="xs" c="dimmed">ÏïåÎ¶º Î∞úÏÜ°</Text>
              <Text size="lg" fw={600} c="green">{logs.filter(l => l.type === 'notification').length}</Text>
            </Card>
            <Card withBorder p="sm" style={{ backgroundColor: 'rgba(239, 68, 68, 0.05)' }}>
              <Text size="xs" c="dimmed">ÏóêÎü¨</Text>
              <Text size="lg" fw={600} c="red">{logs.filter(l => l.type === 'error').length}</Text>
            </Card>
          </Group>

          <Divider />

          <ScrollArea h={400}>
            {isLoadingLogs ? (
              <Text c="dimmed" ta="center" py="xl">Î°úÎî© Ï§ë...</Text>
            ) : filteredLogs.length === 0 ? (
              <Text c="dimmed" ta="center" py="xl">Î°úÍ∑∏Í∞Ä ÏóÜÏäµÎãàÎã§</Text>
            ) : (
              <Timeline active={filteredLogs.length} bulletSize={24} lineWidth={2}>
                {filteredLogs.map(log => (
                  <Timeline.Item
                    key={log.id}
                    bullet={getLogIcon(log.type)}
                    title={log.title}
                  >
                    <Text size="xs" c="dimmed" mb={4}>{formatDateTime(log.timestamp)}</Text>
                    <Text size="sm">{log.message}</Text>
                    {log.error && (
                      <Card withBorder p="xs" mt="xs" style={{ backgroundColor: 'rgba(239, 68, 68, 0.05)' }}>
                        <Text size="xs" c="red">{log.error}</Text>
                      </Card>
                    )}
                    {log.data && (
                      <Card withBorder p="xs" mt="xs" style={{ backgroundColor: 'rgba(148, 163, 184, 0.05)' }}>
                        <Text size="xs" c="dimmed" style={{ fontFamily: 'monospace' }}>
                          {JSON.stringify(log.data, null, 2)}
                        </Text>
                      </Card>
                    )}
                  </Timeline.Item>
                ))}
              </Timeline>
            )}
          </ScrollArea>
        </Stack>
      </Modal>
    </div>
  )
}
